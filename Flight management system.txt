// ================================================================
// LAB 01: Structures, Pointers, Arrays
// (Complete program: ONLY #include <iostream>)
// ================================================================
#include <iostream>
using namespace std;

// -------- Structures: Definition & Access --------
struct Books {
    char title[50];
    char author[50];
    char subject[100];
    int  book_id;
};

void printBookByValue(Books book) {
    cout << "Book title  : " << book.title  << '\n';
    cout << "Book author : " << book.author << '\n';
    cout << "Book subject: " << book.subject<< '\n';
    cout << "Book id     : " << book.book_id<< '\n';
}

void printBookByPtr(Books* book) {
    cout << "Book title  : " << book->title  << '\n';
    cout << "Book author : " << book->author << '\n';
    cout << "Book subject: " << book->subject<< '\n';
    cout << "Book id     : " << book->book_id<< '\n';
}

// -------- Pointers: Demo --------
void pointerDemo() {
    int var1 = 30;
    int* ptr1 = &var1;
    int** ptr2 = &ptr1;

    cout << "Value at ptr1 (address of var1): " << ptr1  << '\n';
    cout << "Value at var1                  : " << var1  << '\n';
    cout << "Value using *ptr1              : " << *ptr1 << '\n';
    cout << "Value at ptr2 (address of ptr1): " << ptr2  << '\n';
    cout << "Value stored at *ptr2 (ptr1)   : " << *ptr2 << '\n';
    cout << "Value using **ptr2 (var1)      : " << **ptr2<< '\n';
}

// -------- Dynamic 2D Array (Array-of-Pointers method) --------
void dynamic2DArrayDemo() {
    int m = 3, n = 4, c = 0;
    int** a = new int*[m];
    for (int i = 0; i < m; ++i) a[i] = new int[n];

    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
            a[i][j] = ++c;

    cout << "\nDynamic 2D Array (3x4):\n";
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) cout << a[i][j] << ' ';
        cout << '\n';
    }

    for (int i = 0; i < m; ++i) delete[] a[i];
    delete[] a;
}

// -------- Practice Problems --------
// Activity 1: Person structure (name, age, salary)
struct Person {
    char name[50];
    int  age;
    float salary;
};

void activity1_person() {
    Person p = {"Ali", 25, 50000.0f};
    cout << "\n[Activity 1]\n";
    cout << "Name: " << p.name << "\nAge: " << p.age << "\nSalary: " << p.salary << '\n';
}

// Activity 2: Students array + queries
struct Student {
    int rollno;
    char name[50];
    int age;
    char address[80];
};

void activity2_students() {
    cout << "\n[Activity 2]\n";
    const int N = 10;
    Student s[N] = {
        {1, "Ahsan", 14, "Hostel 1"},
        {2, "Sara", 13, "Hostel 2"},
        {3, "Bilal", 12, "Hostel 3"},
        {4, "Maya", 14, "Hostel 4"},
        {5, "Raza", 11, "Hostel 5"},
        {6, "Huda", 12, "Hostel 6"},
        {7, "Usman", 13, "Hostel 7"},
        {8, "Noor", 14, "Hostel 8"},
        {9, "Ali", 12, "Hostel 9"},
        {10,"Hassan",11, "Hostel 10"}
    };

    cout << "Names with age 14:\n";
    for (int i = 0; i < N; ++i) if (s[i].age == 14) cout << s[i].name << '\n';

    cout << "\nNames with even roll numbers:\n";
    for (int i = 0; i < N; ++i) if ((s[i].rollno % 2) == 0) cout << s[i].name << '\n';

    int query = 4; // fixed example
    cout << "\nDetails for roll no " << query << ":\n";
    for (int i = 0; i < N; ++i) if (s[i].rollno == query) {
        cout << s[i].name << ", Age: " << s[i].age << ", Address: " << s[i].address << '\n';
        break;
    }
}

// Activity 3: Array + pointer traversal + max
void activity3_arrayPointer() {
    cout << "\n[Activity 3]\n";
    int arr[6] = {5, 9, 1, 7, 2, 8};
    int* p = arr;

    cout << "Array via pointer: ";
    for (int i = 0; i < 6; ++i) cout << *(p + i) << ' ';
    cout << '\n';

    int mx = *p;
    for (int i = 1; i < 6; ++i) if (*(p + i) > mx) mx = *(p + i);
    cout << "Max via pointer: " << mx << '\n';
}

// Activity 4: smallest_value & traversal_back
int smallest_value(int* temp, int size) {
    int small = temp[0];
    for (int i = 1; i < size; ++i) if (temp[i] < small) small = temp[i];
    return small;
}
void traversal_back(int* temp, int size) {
    for (int i = size - 1; i >= 0; --i)
        cout << "Value: " << temp[i] << " at address: " << (temp + i) << '\n';
}

int main() {
    cout << "===== LAB 01: Structures, Pointers, Arrays =====\n\n";

    Books b1 = {"Learn C++ Programming", "Chand Miyan", "C++ Programming", 6495407};
    Books b2 = {"Telecom Billing", "Yakit Singha", "Telecom", 6495700};
    printBookByValue(b1);
    cout << '\n';
    printBookByPtr(&b2);

    cout << "\n--- Pointer Demo ---\n";
    pointerDemo();

    cout << "\n--- Dynamic 2D Array Demo ---\n";
    dynamic2DArrayDemo();

    activity1_person();
    activity2_students();
    activity3_arrayPointer();

    int demo[5] = {5, 2, 9, 1, 3};
    cout << "\n[Activity 4]\nSmallest: " << smallest_value(demo, 5) << '\n';
    traversal_back(demo, 5);

    return 0;
}



// ================================================================
// LAB 02: Abstract Data Types & Singly Linked List
// (Complete program: ONLY #include <iostream>)
// ================================================================
#include <iostream>
using namespace std;

struct SNode {
    int data;
    SNode* next;
    SNode(int d) : data(d), next(nullptr) {}
};

class LinkedList {
public:
    SNode* head;
    LinkedList() : head(nullptr) {}

    void push_back(int val) {
        SNode* n = new SNode(val);
        if (!head) { head = n; return; }
        SNode* t = head;
        while (t->next) t = t->next;
        t->next = n;
    }

    void push_front(int val) {
        SNode* n = new SNode(val);
        n->next = head;
        head = n;
    }

    void pop_front() {
        if (!head) return;
        SNode* t = head;
        head = head->next;
        delete t;
    }

    void pop_back() {
        if (!head) return;
        if (!head->next) { delete head; head = nullptr; return; }
        SNode* t = head;
        while (t->next && t->next->next) t = t->next;
        delete t->next;
        t->next = nullptr;
    }

    bool search(int key) {
        SNode* t = head;
        while (t) { if (t->data == key) return true; t = t->next; }
        return false;
    }

    void print() {
        cout << "List: ";
        SNode* t = head;
        while (t) { cout << t->data << ' '; t = t->next; }
        cout << '\n';
    }
};

// Practice: count, empty, delete specific
int countNodes(SNode* head) {
    int c = 0;
    while (head) { ++c; head = head->next; }
    return c;
}

bool isListEmpty(SNode* head) {
    return head == nullptr;
}

void deleteByValue(SNode*& head, int value) {
    if (!head) return;
    if (head->data == value) {
        SNode* t = head;
        head = head->next;
        delete t;
        return;
    }
    SNode* t = head;
    while (t->next && t->next->data != value) t = t->next;
    if (t->next) {
        SNode* d = t->next;
        t->next = d->next;
        delete d;
    }
}

int main() {
    cout << "===== LAB 02: ADT & Singly Linked List =====\n\n";

    LinkedList ll;
    ll.push_back(10);
    ll.push_back(20);
    ll.push_back(30);
    ll.print();

    cout << "search(20): " << (ll.search(20) ? "found" : "not found") << '\n';
    cout << "search(99): " << (ll.search(99) ? "found" : "not found") << '\n';

    cout << "Node count: " << countNodes(ll.head) << '\n';
    cout << "Is empty?  : " << (isListEmpty(ll.head) ? "true" : "false") << '\n';

    deleteByValue(ll.head, 20);
    ll.print();
    cout << "Node count after delete 20: " << countNodes(ll.head) << '\n';

    deleteByValue(ll.head, 10);
    deleteByValue(ll.head, 30);
    cout << "Is empty after deleting all? " << (isListEmpty(ll.head) ? "true" : "false") << '\n';

    return 0;
}



// ================================================================
// LAB 03: Doubly Linked List
// (Complete program: ONLY #include <iostream>)
// ================================================================
#include <iostream>
using namespace std;

struct DNode {
    int data;
    DNode* next;
    DNode* prev;
    DNode(int d) : data(d), next(nullptr), prev(nullptr) {}
};

class DoublyLinkedList {
public:
    DNode* head;
    DoublyLinkedList() : head(nullptr) {}

    void insertFront(int data) {
        DNode* n = new DNode(data);
        n->next = head;
        if (head) head->prev = n;
        head = n;
    }

    void insertAfter(DNode* prev_node, int data) {
        if (!prev_node) return;
        DNode* n = new DNode(data);
        n->next = prev_node->next;
        n->prev = prev_node;
        if (prev_node->next) prev_node->next->prev = n;
        prev_node->next = n;
    }

    void insertEnd(int data) {
        DNode* n = new DNode(data);
        if (!head) { head = n; return; }
        DNode* t = head;
        while (t->next) t = t->next;
        t->next = n;
        n->prev = t;
    }

    void deleteNode(DNode* del) {
        if (!head || !del) return;
        if (head == del) head = del->next;
        if (del->next) del->next->prev = del->prev;
        if (del->prev) del->prev->next = del->next;
        delete del;
    }

    void print() {
        cout << "DLL: ";
        DNode* t = head;
        while (t) { cout << t->data << ' '; t = t->next; }
        cout << '\n';
    }
};

int main() {
    cout << "===== LAB 03: Doubly Linked List =====\n\n";
    DoublyLinkedList dl;
    dl.insertFront(10);
    dl.insertEnd(20);
    dl.insertEnd(30);
    dl.print();

    if (dl.head) dl.insertAfter(dl.head, 15);
    dl.print();

    DNode* t = dl.head;
    while (t && t->data != 20) t = t->next;
    dl.deleteNode(t);
    dl.print();

    return 0;
}



// ================================================================
// LAB 04: Stack (Array + Linked List)
// (Complete program: ONLY #include <iostream>)
// ================================================================
#include <iostream>
using namespace std;

// -------- Stack using Array --------
#define MAX 5
class StackArray {
    int arr[MAX];
    int top;
public:
    StackArray() : top(-1) {}
    bool isFull()  { return top == MAX - 1; }
    bool isEmpty() { return top == -1; }
    void push(int v) {
        if (isFull()) cout << "Stack is full\n";
        else arr[++top] = v;
    }
    void pop() {
        if (isEmpty()) cout << "Stack is empty\n";
        else --top;
    }
    int peek() { return isEmpty() ? -1 : arr[top]; }
    void print() {
        cout << "Stack(Array): ";
        for (int i = 0; i <= top; ++i) cout << arr[i] << ' ';
        cout << '\n';
    }
};

// -------- Stack using Linked List --------
struct SNodeL4 {
    int data;
    SNodeL4* next;
    SNodeL4(int d) : data(d), next(nullptr) {}
};

class StackList {
    SNodeL4* top;
public:
    StackList() : top(nullptr) {}
    bool isEmpty() { return top == nullptr; }
    void push(int v) {
        SNodeL4* n = new SNodeL4(v);
        n->next = top;
        top = n;
    }
    void pop() {
        if (isEmpty()) { cout << "Stack is empty\n"; return; }
        SNodeL4* t = top; top = top->next; delete t;
    }
    int peek() { return isEmpty() ? -1 : top->data; }
    void print() {
        cout << "Stack(LinkedList): ";
        SNodeL4* t = top;
        while (t) { cout << t->data << ' '; t = t->next; }
        cout << '\n';
    }
};

int main() {
    cout << "===== LAB 04: Stack (Array + Linked List) =====\n\n";

    StackArray sa;
    sa.push(1); sa.push(2); sa.push(3); sa.print();
    cout << "peek: " << sa.peek() << '\n';
    sa.pop(); sa.print();

    StackList sl;
    sl.push(10); sl.push(20); sl.push(30); sl.print();
    cout << "peek: " << sl.peek() << '\n';
    sl.pop(); sl.print();

    return 0;
}



// ================================================================
// LAB 05: Queue (Array + Linked List)
// (Complete program: ONLY #include <iostream>)
// ================================================================
#include <iostream>
using namespace std;

// -------- Queue using Array --------
#define QMAX 5
class QueueArray {
    int a[QMAX];
    int front, rear;
public:
    QueueArray() : front(-1), rear(-1) {}
    bool isEmpty() { return front == -1; }
    bool isFull()  { return rear == QMAX - 1; }
    void enqueue(int v) {
        if (isFull()) { cout << "Queue full\n"; return; }
        if (front == -1) front = 0;
        a[++rear] = v;
    }
    void dequeue() {
        if (isEmpty()) { cout << "Queue empty\n"; return; }
        ++front;
        if (front > rear) front = rear = -1;
    }
    int peek() { return isEmpty() ? -1 : a[front]; }
    void print() {
        if (isEmpty()) { cout << "Queue empty\n"; return; }
        cout << "Queue(Array): ";
        for (int i = front; i <= rear; ++i) cout << a[i] << ' ';
        cout << '\n';
    }
};

// -------- Queue using Linked List --------
struct QNode {
    int data;
    QNode* next;
    QNode(int d) : data(d), next(nullptr) {}
};

class QueueList {
    QNode* front;
    QNode* rear;
public:
    QueueList() : front(nullptr), rear(nullptr) {}
    bool isEmpty() { return front == nullptr; }
    void enqueue(int v) {
        QNode* n = new QNode(v);
        if (!rear) { front = rear = n; return; }
        rear->next = n; rear = n;
    }
    void dequeue() {
        if (isEmpty()) { cout << "Queue empty\n"; return; }
        QNode* t = front; front = front->next; if (!front) rear = nullptr; delete t;
    }
    int peek() { return isEmpty() ? -1 : front->data; }
    void print() {
        cout << "Queue(LinkedList): ";
        QNode* t = front; while (t) { cout << t->data << ' '; t = t->next; } cout << '\n';
    }
};

int main() {
    cout << "===== LAB 05: Queue (Array + Linked List) =====\n\n";

    QueueArray qa;
    qa.enqueue(1); qa.enqueue(2); qa.enqueue(3); qa.print();
    cout << "peek: " << qa.peek() << '\n';
    qa.dequeue(); qa.print();

    QueueList ql;
    ql.enqueue(10); ql.enqueue(20); ql.enqueue(30); ql.print();
    cout << "peek: " << ql.peek() << '\n';
    ql.dequeue(); ql.print();

    return 0;
}



// ================================================================
// COMMON PROBLEM: Singly Linked List - Reverse (Iterative & Recursive)
// (Complete program: ONLY #include <iostream>)
// ================================================================
#include <iostream>
using namespace std;

struct NodeRev {
    int data;
    NodeRev* next;
    NodeRev(int d) : data(d), next(nullptr) {}
};

void pushFront(NodeRev*& head, int val) {
    NodeRev* n = new NodeRev(val);
    n->next = head;
    head = n;
}

NodeRev* reverseIterative(NodeRev* head) {
    NodeRev* prev = nullptr;
    NodeRev* curr = head;
    while (curr) {
        NodeRev* nxt = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nxt;
    }
    return prev;
}

NodeRev* reverseRecursive(NodeRev* head) {
    if (!head || !head->next) return head;
    NodeRev* rest = reverseRecursive(head->next);
    head->next->next = head;
    head->next = nullptr;
    return rest;
}

void printList(NodeRev* head) {
    while (head) { cout << head->data << ' '; head = head->next; }
    cout << '\n';
}

int main() {
    cout << "===== COMMON: Reverse Singly Linked List =====\n\n";
    NodeRev* head = nullptr;
    pushFront(head, 5); pushFront(head, 4); pushFront(head, 3);
    pushFront(head, 2); pushFront(head, 1);
    cout << "Original: "; printList(head);

    head = reverseIterative(head);
    cout << "Reversed (Iterative): "; printList(head);

    head = reverseRecursive(head);
    cout << "Reversed back (Recursive): "; printList(head);

    return 0;
}



// ================================================================
// COMMON PROBLEM: Singly Linked List - Find Middle (Slow/Fast pointers)
// (Complete program: ONLY #include <iostream>)
// ================================================================
#include <iostream>
using namespace std;

struct NodeMid {
    int data;
    NodeMid* next;
    NodeMid(int d) : data(d), next(nullptr) {}
};

void append(NodeMid*& head, int val) {
    NodeMid* n = new NodeMid(val);
    if (!head) { head = n; return; }
    NodeMid* t = head; while (t->next) t = t->next; t->next = n;
}

NodeMid* findMiddle(NodeMid* head) {
    NodeMid* slow = head;
    NodeMid* fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}

void printList(NodeMid* head) { while (head){ cout<<head->data<<' '; head=head->next; } cout<<'\n'; }

int main() {
    cout << "===== COMMON: Find Middle of Singly Linked List =====\n\n";
    NodeMid* head = nullptr;
    for (int i = 1; i <= 7; ++i) append(head, i);
    printList(head);
    NodeMid* mid = findMiddle(head);
    if (mid) cout << "Middle: " << mid->data << '\n';
    return 0;
}



// ================================================================
// COMMON PROBLEM: Singly Linked List - Detect Loop (Floyd's Cycle)
// (Complete program: ONLY #include <iostream>)
// ================================================================
#include <iostream>
using namespace std;

struct NodeLoop {
    int data;
    NodeLoop* next;
    NodeLoop(int d) : data(d), next(nullptr) {}
};

bool hasLoop(NodeLoop* head) {
    NodeLoop* slow = head;
    NodeLoop* fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}

int main() {
    cout << "===== COMMON: Detect Loop in Singly Linked List =====\n\n";
    NodeLoop* a = new NodeLoop(1);
    NodeLoop* b = new NodeLoop(2);
    NodeLoop* c = new NodeLoop(3);
    NodeLoop* d = new NodeLoop(4);
    a->next = b; b->next = c; c->next = d; d->next = nullptr; // no loop
    cout << "Has loop? " << (hasLoop(a) ? "Yes" : "No") << '\n';
    d->next = b; // create loop
    cout << "Has loop after linking d->next=b? " << (hasLoop(a) ? "Yes" : "No") << '\n';
    // Note: memory leak acceptable for demo; loop prevents safe deletion.
    return 0;
}



// ================================================================
// COMMON PROBLEM: Stack - Reverse a Stack using Recursion
// (Complete program: ONLY #include <iostream>)
// ================================================================
#include <iostream>
using namespace std;

class StackArr {
    int a[50];
    int top;
public:
    StackArr() : top(-1) {}
    bool isEmpty() { return top == -1; }
    bool isFull()  { return top == 49; }
    void push(int v){ if(!isFull()) a[++top]=v; }
    int  pop(){ if(!isEmpty()) return a[top--]; return -1; }
    int  peek(){ return isEmpty() ? -1 : a[top]; }
    void print(){ cout<<"Stack: "; for(int i=0;i<=top;++i) cout<<a[i]<<' '; cout<<'\n'; }
};

void insertAtBottom(StackArr& s, int x){
    if(s.isEmpty()){ s.push(x); return; }
    int t = s.pop();
    insertAtBottom(s, x);
    s.push(t);
}

void reverseStack(StackArr& s){
    if(s.isEmpty()) return;
    int t = s.pop();
    reverseStack(s);
    insertAtBottom(s, t);
}

int main(){
    cout << "===== COMMON: Reverse Stack using Recursion =====\n\n";
    StackArr s; s.push(1); s.push(2); s.push(3); s.push(4);
    s.print();
    reverseStack(s);
    cout << "After reverse:\n";
    s.print();
    return 0;
}



// ================================================================
// COMMON PROBLEM: Stack - Sort a Stack using Recursion
// (Complete program: ONLY #include <iostream>)
// ================================================================
#include <iostream>
using namespace std;

class StackSort {
    int a[50]; int top;
public:
    StackSort(): top(-1) {}
    bool isEmpty(){ return top==-1; }
    bool isFull(){ return top==49; }
    void push(int v){ if(!isFull()) a[++top]=v; }
    int pop(){ return isEmpty()? -1 : a[top--]; }
    int peek(){ return isEmpty()? -1 : a[top]; }
    void print(){ cout<<"Stack: "; for(int i=0;i<=top;++i) cout<<a[i]<<' '; cout<<'\n'; }
};

void sortedInsert(StackSort& s, int x){
    if(s.isEmpty() || s.peek()<=x){ s.push(x); return; }
    int t = s.pop();
    sortedInsert(s, x);
    s.push(t);
}
void sortStack(StackSort& s){
    if(s.isEmpty()) return;
    int t = s.pop();
    sortStack(s);
    sortedInsert(s, t);
}

int main(){
    cout << "===== COMMON: Sort Stack using Recursion =====\n\n";
    StackSort s; s.push(3); s.push(1); s.push(4); s.push(2);
    cout<<"Before sort:\n"; s.print();
    sortStack(s);
    cout<<"After sort:\n"; s.print();
    return 0;
}



// ================================================================
// COMMON PROBLEM: Queue - Reverse a Queue using a Stack
// (Complete program: ONLY #include <iostream>)
// ================================================================
#include <iostream>
using namespace std;

class QueueA {
    int a[50]; int f,r;
public:
    QueueA(): f(-1), r(-1) {}
    bool isEmpty(){ return f==-1; }
    bool isFull(){ return r==49; }
    void enqueue(int v){ if(isFull()) return; if(f==-1) f=0; a[++r]=v; }
    int dequeue(){ if(isEmpty()) return -1; int v=a[f++]; if(f>r) f=r=-1; return v; }
    int peek(){ return isEmpty()? -1 : a[f]; }
    void print(){ if(isEmpty()){ cout<<"Queue empty\n"; return;} cout<<"Queue: "; for(int i=f;i<=r;++i) cout<<a[i]<<' '; cout<<'\n'; }
};

class StackA50 {
    int a[50]; int t;
public:
    StackA50(): t(-1) {}
    bool isEmpty(){ return t==-1; }
    bool isFull(){ return t==49; }
    void push(int v){ if(!isFull()) a[++t]=v; }
    int pop(){ return isEmpty()? -1 : a[t--]; }
};

void reverseQueue(QueueA& q){
    StackA50 s;
    while(!q.isEmpty()) s.push(q.dequeue());
    while(!s.isEmpty()) q.enqueue(s.pop());
}

int main(){
    cout << "===== COMMON: Reverse Queue using Stack =====\n\n";
    QueueA q; q.enqueue(1); q.enqueue(2); q.enqueue(3); q.print();
    reverseQueue(q);
    cout<<"After reverse:\n"; q.print();
    return 0;
}



// ================================================================
// COMMON PROBLEM: Queue using Two Stacks
// (Complete program: ONLY #include <iostream>)
// ================================================================
#include <iostream>
using namespace std;

class StackX {
    int a[100]; int t;
public:
    StackX(): t(-1) {}
    bool isEmpty(){ return t==-1; }
    bool isFull(){ return t==99; }
    void push(int v){ if(!isFull()) a[++t]=v; }
    int pop(){ return isEmpty()? -1 : a[t--]; }
    int peek(){ return isEmpty()? -1 : a[t]; }
};

class QueueTwoStacks {
    StackX s1, s2;
public:
    void enqueue(int v){ s1.push(v); }
    int dequeue(){
        if(s2.isEmpty()){
            while(!s1.isEmpty()) s2.push(s1.pop());
        }
        return s2.pop();
    }
    bool isEmpty(){ return s1.isEmpty() && s2.isEmpty(); }
    int front(){
        if(s2.isEmpty()){
            while(!s1.isEmpty()) s2.push(s1.pop());
        }
        return s2.peek();
    }
    void print(){
        // For demo: move all to s2 to print in order, then move back.
        while(!s2.isEmpty()) s1.push(s2.pop());
        while(!s1.isEmpty()){ s2.push(s1.pop()); }
        // now s2 has front at top; print by popping to temp then restoring
        StackX temp;
        while(!s2.isEmpty()){ int v=s2.pop(); temp.push(v); }
        cout<<"Queue: ";
        while(!temp.isEmpty()){ int v=temp.pop(); cout<<v<<' '; s2.push(v); }
        cout<<'\n';
    }
};

int main(){
    cout << "===== COMMON: Queue implemented using Two Stacks =====\n\n";
    QueueTwoStacks q;
    q.enqueue(10); q.enqueue(20); q.enqueue(30);
    q.print();
    cout<<"front: "<<q.front()<<'\n';
    cout<<"dequeue: "<<q.dequeue()<<'\n';
    q.print();
    q.enqueue(40); q.print();
    return 0;
}





LINKEDLIST START END

#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
};

// Head pointer
Node* head = NULL;

// Insert at the beginning
void insertAtStart(int value) {
    Node* newNode = new Node();
    newNode->data = value;
    newNode->next = head;
    head = newNode;
}

// Insert at the end
void insertAtEnd(int value) {
    Node* newNode = new Node();
    newNode->data = value;
    newNode->next = NULL;

    if (head == NULL) {
        head = newNode;
        return;
    }

    Node* temp = head;
    while (temp->next != NULL)
        temp = temp->next;

    temp->next = newNode;
}

// Delete from the beginning
void deleteAtStart() {
    if (head == NULL) {
        cout << "List is empty!" << endl;
        return;
    }

    Node* temp = head;
    head = head->next;
    delete temp;
}

// Delete from the end
void deleteAtEnd() {
    if (head == NULL) {
        cout << "List is empty!" << endl;
        return;
    }

    if (head->next == NULL) {
        delete head;
        head = NULL;
        return;
    }

    Node* temp = head;
    while (temp->next->next != NULL)
        temp = temp->next;

    delete temp->next;
    temp->next = NULL;
}

// Display all nodes
void display() {
    if (head == NULL) {
        cout << "List is empty!" << endl;
        return;
    }

    Node* temp = head;
    cout << "Linked List: ";
    while (temp != NULL) {
        cout << temp->data << " -> ";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}

// Main function
int main() {
    insertAtEnd(10);
    insertAtEnd(20);
    insertAtStart(5);
    display();

    deleteAtStart();
    display();

    deleteAtEnd();
    display();

    return 0;
}
